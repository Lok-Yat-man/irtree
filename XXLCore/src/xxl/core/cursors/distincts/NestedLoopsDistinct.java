/* XXL: The eXtensible and fleXible Library for data processing

Copyright (C) 2000-2004 Prof. Dr. Bernhard Seeger
                        Head of the Database Research Group
                        Department of Mathematics and Computer Science
                        University of Marburg
                        Germany

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307,
USA

	http://www.xxl-library.de

bugs, requests for enhancements: request@xxl-library.de

If you want to be informed on new versions of XXL you can
subscribe to our mailing-list. Send an email to

	xxl-request@lists.uni-marburg.de

without subject and the word "subscribe" in the message body.
*/

package xxl.core.cursors.distincts;

import java.util.Iterator;

import xxl.core.collections.bags.Bag;
import xxl.core.collections.queues.Queue;
import xxl.core.cursors.AbstractCursor;
import xxl.core.cursors.Cursor;
import xxl.core.cursors.Cursors;
import xxl.core.cursors.wrappers.QueueCursor;
import xxl.core.functions.Function;
import xxl.core.predicates.Equal;
import xxl.core.predicates.Predicate;

/**
 * A nested-loops implementation of the distinct operator, i.e., all duplicates
 * contained in a cursor will be removed. Depending on the specified memory size
 * and object size as many elements of the input cursor as possible will be
 * inserted into a temporal bag (typically located in main memory). To guarantee
 * that no duplicates will be inserted into it, the bag is searched for
 * duplicates with the help of a user defined predicate. If not all elements can
 * be inserted into the bag they will be temporarily stored in a queue, that is
 * typically resided in external memory, and will be inserted when the bag has
 * been emptied due to calls to the <tt>next</tt> method of this class.
 * 
 * <p><b>Example usage (1):</b>
 * <pre>
 *     NestedLoopsDistinct distinct = new NestedLoopsDistinct(
 *         new RandomIntegers(21, 30),
 *         32,
 *         4
 *     );
 * 
 *     distinct.open();
 * 
 *     while(distinct.hasNext())
 *         System.out.println(distinct.next());
 * 
 *     distinct.close();
 * </pre>
 * The input cursor shown in this example deliveres 30 randomly distributed
 * integer numbers contained in the interval [0, 20]. The main memory size is
 * set to 32 bytes and the object size to 4 bytes. So the
 * {@link xxl.core.collections.bags.ListBag list-bag} generated by the factory
 * method of the class {@link xxl.core.collections.bags.Bag} that is used in this
 * case as default is able to hold a maximum 3 elements in main memory. The
 * remaining one element, that fits in main memory, is reserved for the
 * comparison of two elements. Due to the fact that not all elements of the
 * input cursor can be stored in the temporal main memory bag, the remaining
 * elements will be stored in an
 * {@link xxl.core.collections.queues.ArrayQueue array-queue} returned by the
 * factory method of the class {@link xxl.core.collections.queues.Queue} that is
 * used as default. Normally this queue should be placed in external memory.
 * Running this example shows that no duplicates are returned by this
 * operator.</p>
 * 
 * <p><b>Note:</b> If an input iteration is given by an object of the class
 * {@link java.util.Iterator}, i.e., it does not support the <tt>peek</tt>
 * operation, it is internally wrapped to a cursor.</p>
 *
 * @see java.util.Iterator
 * @see xxl.core.cursors.Cursor
 * @see xxl.core.collections.bags.Bag
 * @see xxl.core.collections.queues.Queue
 * @see xxl.core.cursors.distincts.SortBasedDistinct
 * @see xxl.core.relational.cursors.NestedLoopsDistinct
 */
public class NestedLoopsDistinct extends AbstractCursor {

	/**
	 * The input cursor delivering the elements for the distinct operation.
	 */
	protected Cursor cursor;

	/**
	 * The result cursor delivering only distinct elements of the input cursor.
	 */
	protected Cursor results = null;

	/**
	 * A queue used to store the remaining elements during the operation if not
	 * all elements can be stored in the temporal main memory bag.
	 */
	protected Queue remainder = null;

	/**
	 * A parameterless function returning an empty bag on demand.
	 */
	protected Function newBag;

	/**
	 * A parameterless function returning an empty queue on demand.
	 */
	protected Function newQueue;

	/**
	 * An unary predicate determining if two elements are equal. If the returned
	 * value is <tt>true</tt> the given element and the next element of the
	 * internal used cursor that holds all remaining elements do match.
	 */
	protected Predicate predicate;

	/**
	 * The maximum number of elements that can be stored in the bag returned by
	 * the function <tt>newBag</tt>.
	 */
	protected int maxTuples;

	/**
	 * An internal used flag signaling if the elements inserted into the bag are
	 * delivered from the input cursor or the queue <tt>remainder</tt>.
	 */
	protected boolean initialized = false;

	/**
	 * Creates a new instance of the nested-loops distinct operator. The input
	 * iterator is wrapped to a cursor. Determines the maximum number of elements
	 * that can be stored in the bag used for the temporal storage of the
	 * elements of the input cursor:
	 * <pre>
	 *     maxTuples = memSize / objectSize - 1
	 * </pre>
	 *
	 * @param input the input iterator delivering the elements.
	 * @param memSize the maximum amount of available main memory (bytes) for the
	 *        bag.
	 * @param objectSize the size (bytes) needed to store one element.
	 * @param predicate the binary predicate returning <tt>true</tt> if two
	 *        elements are equal.
	 * @param newBag a parameterless function returning an empty bag.
	 * @param newQueue a parameterless function returning an empty queue.
	 * @throws IllegalArgumentException if not enough main memory is available.
	 */
	public NestedLoopsDistinct(Iterator input, int memSize, int objectSize, Predicate predicate, Function newBag, Function newQueue) throws IllegalArgumentException {
		this.cursor = Cursors.wrap(input);
		this.newBag = newBag;
		this.newQueue = newQueue;
		this.predicate = predicate;
		this.maxTuples = memSize / objectSize - 1;
		if (memSize < 2*objectSize)
			throw new IllegalArgumentException("insufficient main memory available.");
	}

	/**
	 * Creates a new instance of the nested-loops distinct operator. The input
	 * iterator is wrapped to a cursor. Determines the maximum number of elements
	 * that can be stored in the bag used for the temporal storage of the
	 * elements of the input cursor:
	 * <pre>
	 *     maxTuples = memSize / objectSize - 1
	 * </pre>
	 * Uses the factory methods for bags,
	 * {@link xxl.core.collections.bags.Bag#FACTORY_METHOD}, and queues,
	 * {@link xxl.core.collections.queues.Queue#FACTORY_METHOD}. Determines the
	 * equality between two elements with the help of the default instance of the
	 * predicate {@link xxl.core.predicates.Equal}.
	 *
	 * @param input the input iterator delivering the elements.
	 * @param memSize the maximum amount of available main memory (bytes) for the
	 *        bag.
	 * @param objectSize the size (bytes) needed to store one element.
	 * @throws IllegalArgumentException if not enough main memory is available.
	 */
	public NestedLoopsDistinct(Iterator input, int memSize, int objectSize) throws IllegalArgumentException {
		this(input, memSize, objectSize, Equal.DEFAULT_INSTANCE, Bag.FACTORY_METHOD, Queue.FACTORY_METHOD);
	}

	/**
	 * Opens the nested-loops distinct operator, i.e., signals the cursor to
	 * reserve resources, open the input iteration, etc. Before a cursor has been
	 * opened calls to methods like <tt>next</tt> or <tt>peek</tt> are not
	 * guaranteed to yield proper results. Therefore <tt>open</tt> must be called
	 * before a cursor's data can be processed. Multiple calls to <tt>open</tt>
	 * do not have any effect, i.e., if <tt>open</tt> was called the cursor
	 * remains in the state <i>opened</i> until its <tt>close</tt> method is
	 * called.
	 * 
	 * <p>Note, that a call to the <tt>open</tt> method of a closed cursor
	 * usually does not open it again because of the fact that its state
	 * generally cannot be restored when resources are released respectively
	 * files are closed.</p>
	 */
	public void open() {
		super.open();
		cursor.open();
	}
	
	/**
	 * Closes the nested-loops distinct operator. Signals the operator to clean
	 * up resources, close the input cursor as well as the internally used bag
	 * and queue. After a call to <tt>close()</tt> calls to methods like
	 * <tt>next</tt> or <tt>peek</tt> are not guaranteed to yield proper results.
	 * Multiple calls to <tt>close</tt> do not have any effect, i.e., if
	 * <tt>close</tt> was called the nested-loops distinct operator remains in
	 * the state "closed".
	 */
	public void close() {
		super.close();
		if (remainder != null)
			remainder.close();
		cursor.close();
		results.close();
	}

	/**
	 * Returns <tt>true</tt> if the iteration has more elements. (In other words,
	 * returns <tt>true</tt> if <tt>next</tt> or <tt>peek</tt> would return an
	 * element rather than throwing an exception.)
	 * 
	 * <p>Builds a temporal bag calling <tt>newBag.invoke()</tt> and stores as
	 * much distinct elements of the input cursor in this bag as possible. After
	 * that all remaining elements of the input cursor are inserted in the queue
	 * <tt>remainder</tt>. With the intention to guarantee that no duplicate
	 * elements are inserted in the temporal bag the bag's <t>query</t> method
	 * verifying each element concerning the specified predicate is called.<br />
	 * An element is only inserted if the result of the <tt>query</tt> method (a
	 * cursor) is empty. At last the bag's <tt>cursor</tt> method is called and
	 * the result cursor's reference is set to this cursor. If the result cursor
	 * contains any elements, <tt>true</tt> is returned, otherwise
	 * <tt>false</tt>. If the queue <tt>remainder</tt> contains further elements
	 * the whole procedure is returned by the next call to this method and at
	 * this time the elements inserted in the temporal bag are delivered by the
	 * queue.
	 *
	 * @return <tt>true</tt> if the nested-loops distinct operator has more
	 *         elements.
	 */
	protected boolean hasNextObject() {
		if (results == null || !results.hasNext()) {
			Cursor input = initialized ?
				(Cursor)new QueueCursor(remainder) :
				cursor;
			Bag tmpBag = (Bag)newBag.invoke();
			int counter = 0;
			if (initialized && remainder != null)
				counter = remainder.size();
			while((!initialized && input.hasNext()) || (initialized && counter-- > 0)) {
				final Object next = input.next();
				if (!tmpBag.query(
					new Predicate () {
						public boolean invoke (Object o) {
							return predicate.invoke(o, next);
						}
					}
				).hasNext())
					if(tmpBag.size() < maxTuples)
						tmpBag.insert(next);
					else {
						if(remainder == null)
							(remainder = (Queue)newQueue.invoke()).open();
						remainder.enqueue(next);
					}
			}
			initialized = true;
			results = tmpBag.cursor();
			return results.hasNext();
		}
		return true;
	}

	/**
	 * Returns the next element in the iteration. This element will be removed
	 * from the iteration, if <tt>next</tt> is called.
	 *
	 * @return the next element in the iteration.
	 */
	protected Object nextObject() {
		Object result = results.next();
		results.remove();
		return result;
	}

	/**
	 * Resets the nested-loops distinct operator to its initial state (optional
	 * operation). So the caller is able to traverse the underlying data
	 * structure again. The modifications, removes and updates concerning the
	 * underlying data structure, are still persistent. This method resets the
	 * input iteration, closes the result cursor, sets it to <tt>null</tt> and
	 * clears the queue <tt>remainder</tt>.
	 *
	 * @throws UnsupportedOperationException if the <tt>reset</tt> operation is
	 *         not supported by the nested-loops distinct operator.
	 */
	public void reset() throws UnsupportedOperationException {
		super.reset();
		if (remainder != null)
			remainder.clear();
		cursor.reset();
		results.close();
		results = null;
		initialized = false;
	}
	
	/**
	 * Returns <tt>true</tt> if the <tt>reset</tt> operation is supported by
	 * the nested-loops distinct operator. Otherwise it returns <tt>false</tt>.
	 *
	 * @return <tt>true</tt> if the <tt>reset</tt> operation is supported by
	 *         the cursor, otherwise <tt>false</tt>.
	 */
	public boolean supportsReset() {
		return cursor.supportsReset();
	}

	/**
	 * The main method contains some examples to demonstrate the usage and the
	 * functionality of this class.
	 *
	 * @param args array of <tt>String</tt> arguments. It can be used to submit
	 *        parameters when the main method is called.
	 */
	public static void main(String[] args) {

		/*********************************************************************/
		/*                            Example 1                              */
		/*********************************************************************/
		
		NestedLoopsDistinct distinct = new NestedLoopsDistinct(
			new xxl.core.cursors.sources.RandomIntegers(21, 30),
			32,
			4
			//Bag.FACTORY_METHOD,
			//Queue.FACTORY_METHOD
		);
		
		distinct.open();
		
		while(distinct.hasNext())
			System.out.println(distinct.next());
		
		distinct.close();
	}
}
