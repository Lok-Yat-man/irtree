/* XXL: The eXtensible and fleXible Library for data processing

Copyright (C) 2000-2004 Prof. Dr. Bernhard Seeger
                        Head of the Database Research Group
                        Department of Mathematics and Computer Science
                        University of Marburg
                        Germany

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307,
USA

	http://www.xxl-library.de

bugs, requests for enhancements: request@xxl-library.de

If you want to be informed on new versions of XXL you can 
subscribe to our mailing-list. Send an email to 
	
	xxl-request@lists.uni-marburg.de

without subject and the word "subscribe" in the message body. 
*/
package xxl.core.cursors.joins;

import java.util.Comparator;
import java.util.Iterator;

import xxl.core.collections.sweepAreas.SortMergeEquiJoinSA;
import xxl.core.functions.Function;

/**
 * A sort-merge implementation of the equivalence-join operator (especially the
 * equi-join). This class provides a generic, untyped sort-merge join algorithm.
 * The join predicate has to be a equivalence-relation and the elements of both
 * input iterations have to be sortable according to an order which provides the
 * members of the equivalence-classes in sequence. In contrast to the upper class
 * {@link xxl.core.cursors.joins.SortMergeJoin}, the sort-merge equivalence-join
 * provides support for left-outer, right-outer and full outer joins. The
 * resulting tuples of any join operation are generated by a user defined
 * function realizing a kind of factory method. The binary function
 * <tt>newResult</tt> can be used to map the result tuples to an arbitrary user
 * defined type. The sweep-line status structure, here called sweep-area,
 * consists of a bag with an additional method for reorganisation. The way the
 * elements of the input iterations are inserted into the according sweep-area is
 * determined by a given comparator. If no comparator has been specified, a
 * default instance of the class
 * {@link xxl.core.comparators.ComparableComparator} is used instead. Depending
 * on the result of the comparison of the two next input elements of the input
 * iterations, the left (<tt>sortedInput0</tt>) or right (<tt>sortedInput1</tt>)
 * input is processed. If the left input is processed, the sweep-area's of
 * <tt>sortedInput0</tt> and <tt>sortedInput1</tt> are reorganized and the next
 * element of <tt>sortedInput0</tt> is inserted in <tt>sweepArea0</tt>. After
 * that <tt>sweepArea1</tt> is queried with this element, i.e., the specified
 * predicate is applied on the elements contained in <tt>sweepArea1</tt> and the
 * last inserted element of <tt>sweepArea0</tt>. In order to perform an effective
 * search in the sweep-area, the query method of the bags should be overriden. If
 * the binary predicate returns <tt>true</tt> the evaluated tuple gets an result
 * of the join operation. After that query the mapping function to create the
 * result-tuples is applied on the results detected by the predicate and after
 * that they are returned to the user. The right input is processed analogous.
 * The implementation is a bit more complex due to addional checks of join-types
 * and the generation of result-tuples where the evaluated join predicate
 * returned <tt>false</tt>.
 * 
 * <p><b>Note:</b> When the given input iteration only implements the interface
 * {@link java.util.Iterator} it is wrapped to a cursor by a call to the static
 * method {@link xxl.core.cursors.Cursors#wrap(Iterator) wrap}.</p>
 * 
 * <p><b>Example usage (1):</b>
 * <pre>
 *     LinkedList l1 = new LinkedList();
 *     final LinkedList l2 = new LinkedList();
 *     for (int i = 0; i &le; 10; i++) {
 *         // left: odd numbers or can be divided by 4
 *         if (i%2 != 0 || i%4 == 0)
 *             l1.add(new Integer(i));
 *         //right: even numbers
 *         if (i%2 == 0)
 *             l2.add(new Integer(i));
 *     }
 * 
 *     SortMergeEquivalenceJoin join = new SortMergeEquivalenceJoin(
 *         l1.listIterator(),
 *         l2.listIterator(),
 *         new SortMergeEquiJoinSA(
 *             new ListSAImplementor(),
 *             0,
 *             2
 *         ),
 *         new SortMergeEquiJoinSA(
 *             new ListSAImplementor(),
 *             1,
 *             2
 *         ),
 *         ComparableComparator.DEFAULT_INSTANCE,
 *         Function.IDENTITY,
 *         OUTER_JOIN
 *     );
 * 
 *     join.open();
 * 
 *     while (join.hasNext()) {
 *         Object[] result = (Object[])join.next();
 *         System.out.println("Tuple: (" + result[0] + ", " + result[1] + ")");
 *     }
 * 
 *     join.close();
 * </pre>
 * The input iterations of this simple example are two list iterators. The first
 * one is based on all odd numbers and numbers that can be divided by 4 of the
 * interval [0, 10]. The second input iterator contains all even numbers of the
 * same interval. The join predicate, an
 * {@link xxl.core.predicates.Equal equalality} predicate, is encapsulated in the
 * given sweep-areas based on a {@link java.util.List list}. In order to compare
 * an element of <tt>sortedInput0</tt> and an element of <tt>sortedInput1</tt>,
 * a default {@link xxl.core.comparators.ComparableComparator comparator} is used
 * which assumes that the input iterators' elements implement the
 * {@link java.lang.Comparable comparable} interface. In this example no
 * specific function is specified to create user defined result-tuples. The
 * {@link xxl.core.functions.Function#IDENTITY identity} function delivers the
 * result-tuples in their original representation, namely as an array containing
 * the matching elements of the input iterations. This can simply be seen when
 * printing the result-tuples to the output stream. But in the package
 * {@link xxl.core.relational} there are different factory methods creating a
 * particular kind of tuple, e.g.,
 * {@link xxl.core.relational.ArrayTuple array-tuple},
 * {@link xxl.core.relational.ListTuple list-tuple}, that substitute the identity
 * function. So, let us consider the output of this join operation, which looks
 * as follows:
 * <pre>
 *     Tuple: (0, 0)
 *     Tuple: (1, null)
 *     Tuple: (null, 2)
 *     Tuple: (3, null)
 *     Tuple: (4, 4)
 *     Tuple: (5, null)
 *     Tuple: (null, 6)
 *     Tuple: (7, null)
 *     Tuple: (8, 8)
 *     Tuple: (9, null)
 *     Tuple: (null, 10)
 * </pre></p>
 * 
 * @see java.util.Iterator
 * @see xxl.core.cursors.Cursor
 * @see xxl.core.cursors.joins.NestedLoopsJoin
 * @see xxl.core.cursors.joins.SortMergeJoin
 */
public class SortMergeEquivalenceJoin extends SortMergeJoin {

	/**
	 * Creates a new sort-merge equivalence-join operator backed on two sorted
	 * input iterations using the given sweep-areas to store the input
	 * iterations' elements and probe for join results. Furthermore a function
	 * named <tt>newResult</tt> can be specified that is invoked on each
	 * qualifying tuple before it is returned to the caller concerning a call to
	 * the <tt>next</tt> method. This function is a kind of factory method to
	 * model the resulting object.
	 * 
	 * <p><b>Precondition:</b> The input cursors have to be sorted and the join
	 * predicate has to be an equivalence-relation!</p>
	 * 
	 * <p>The result-tuples created by this operator are represented as an array
	 * of the input iterations' elements that are participated in this join
	 * result. If the user wants to specify a different result-type, a mapping
	 * function <tt>newResult</tt> can be specified. This function works like a
	 * kind of factory method modelling the resulting object (tuple). Further a
	 * set of comparators have to be specified, in order to compare the elements
	 * of different input iterations. Every iterator given to this constructor is
	 * wrapped to a cursor.<p>
	 *
	 * @param sortedInput0 the first sorted input iteration to be joined.
	 * @param sortedInput1 the second sorted input iteration to be joined.
	 * @param sweepArea0 the sweep-area used for storing elements of the first
	 *        sorted input iteration (<tt>sortedInput0</tt>).
	 * @param sweepArea1 the sweep-area used for storing elements of the second
	 *        sorted input iteration (<tt>sortedInput1</tt>).
	 * @param comparator the comparator that is used for comparing elements of
	 *        the two sorted input iterations.
	 * @param newResult a factory method (function) that takes two parameters as
	 *        argument and is invoked on each tuple where the predicate's
	 *        evaluation result is <tt>true</tt>, i.e., on each qualifying tuple
	 *        before it is returned to the caller concerning a call to the
	 *        <tt>next</tt> method.
	 * @param type the type of this join; use one of the public constants defined
	 *        in this class.
	 * @throws IllegalArgumentException if the specified type is not valid.
	 */
	public SortMergeEquivalenceJoin(Iterator sortedInput0, Iterator sortedInput1, SortMergeEquiJoinSA sweepArea0, SortMergeEquiJoinSA sweepArea1, Comparator comparator, Function newResult, int type) throws IllegalArgumentException {
		super(sortedInput0, sortedInput1, sweepArea0, sweepArea1, comparator, newResult);
		this.type = type;
	}

	/**
	 * Creates a new sort-merge equivalence-join operator backed on two input
	 * iterations using the given sweep-areas to store the input iterations'
	 * elements and probe for join results. The constructor does not require the
	 * two input iterations to be sorted. The two specified, unary functions
	 * <tt>newSorter0</tt> and <tt>newSorter1</tt> will be invoked on the
	 * corresponding input iteration in order to get a sorted input. Furthermore
	 * a function named <tt>newResult</tt> can be specified that is invoked on
	 * each qualifying tuple before it is returned to the caller concerning a
	 * call to the <tt>next</tt> method. This function is a kind of factory
	 * method to model the resulting object.
	 * 
	 * <p><b>Precondition:</b> The join predicate has to be an
	 * equivalence-relation!</p>
	 * 
	 * <p>The result-tuples created by this operator are represented as an array
	 * of the input iterations' elements that are participated in this join
	 * result. If the user wants to specify a different result-type, a mapping
	 * function <tt>newResult</tt> can be specified. This function works like a
	 * kind of factory method modelling the resulting object (tuple). Further a
	 * set of comparators have to be specified, in order to compare the elements
	 * of different input iterations. Every iterator given to this constructor is
	 * wrapped to a cursor.<p>
	 *
	 * @param input0 the first input iteration to be joined.
	 * @param input1 the second input iteration to be joined.
	 * @param newSorter0 an unary function that sorts the first input iteration
	 *        <tt>input0</tt>.
	 * @param newSorter1 an unary function that sorts the second input iteration
	 *        <tt>input1</tt>.
	 * @param sweepArea0 the sweep-area used for storing elements of the first
	 *        input iteration (<tt>input0</tt>).
	 * @param sweepArea1 the sweep-area used for storing elements of the second
	 *        input iteration (<tt>input1</tt>).
	 * @param comparator the comparator that is used for comparing elements of
	 *        the two input iterations.
	 * @param newResult a factory method (function) that takes two parameters as
	 *        argument and is invoked on each tuple where the predicate's
	 *        evaluation result is <tt>true</tt>, i.e., on each qualifying tuple
	 *        before it is returned to the caller concerning a call to the
	 *        <tt>next</tt> method.
	 * @param type the type of this join; use one of the public constants defined
	 *        in this class.
	 * @throws IllegalArgumentException if the specified type is not valid.
	 */
	public SortMergeEquivalenceJoin(Iterator input0, Iterator input1, Function newSorter0, Function newSorter1, SortMergeEquiJoinSA sweepArea0, SortMergeEquiJoinSA sweepArea1, Comparator comparator, Function newResult, int type) throws IllegalArgumentException {
		super(input0, input1, newSorter0, newSorter1, sweepArea0, sweepArea1, comparator, newResult);
		this.type = type;
	}

	/**
	 * Creates a new sort-merge equivalence-join operator backed on two sorted
	 * input iterations using the given sweep-areas to store the input
	 * iterations' elements and probe for join results. Uses a default
	 * {@link xxl.core.comparators.ComparableComparator comparator} for the
	 * comparison of the input cursors' elements which assumes that these
	 * elements implement the {@link java.lang.Comparable comparable} interface.
	 * Furthermore a function named <tt>newResult</tt> can be specified that is
	 * invoked on each qualifying tuple before it is returned to the caller
	 * concerning a call to the <tt>next</tt> method. This function is a kind of
	 * factory method to model the resulting object.
	 * 
	 * <p><b>Precondition:</b> The input cursors have to be sorted and the join
	 * predicate has to be an equivalence-relation!</p>
	 * 
	 * <p>The result-tuples created by this operator are represented as an array
	 * of the input iterations' elements that are participated in this join
	 * result. If the user wants to specify a different result-type, a mapping
	 * function <tt>newResult</tt> can be specified. This function works like a
	 * kind of factory method modelling the resulting object (tuple). Further a
	 * set of comparators have to be specified, in order to compare the elements
	 * of different input iterations. Every iterator given to this constructor is
	 * wrapped to a cursor.<p>
	 *
	 * @param sortedInput0 the first sorted input iteration to be joined.
	 * @param sortedInput1 the second sorted input iteration to be joined.
	 * @param sweepArea0 the sweep-area used for storing elements of the first
	 *        sorted input iteration (<tt>sortedInput0</tt>).
	 * @param sweepArea1 the sweep-area used for storing elements of the second
	 *        sorted input iteration (<tt>sortedInput1</tt>).
	 * @param newResult a factory method (function) that takes two parameters as
	 *        argument and is invoked on each tuple where the predicate's
	 *        evaluation result is <tt>true</tt>, i.e., on each qualifying tuple
	 *        before it is returned to the caller concerning a call to the
	 *        <tt>next</tt> method.
	 * @param type the type of this join; use one of the public constants defined
	 *        in this class.
	 * @throws IllegalArgumentException if the specified type is not valid.
	 */
	public SortMergeEquivalenceJoin(Iterator sortedInput0, Iterator sortedInput1, SortMergeEquiJoinSA sweepArea0, SortMergeEquiJoinSA sweepArea1, Function newResult, int type) throws IllegalArgumentException {
		super(sortedInput0, sortedInput1, sweepArea0, sweepArea1, newResult);
		this.type = type;
	}

	/**
	 * Creates a new sort-merge equivalence-join operator backed on two sorted
	 * input iterations using a parameterless function to create the required 
	 * sweep-areas that are used to store the input iterations' elements and
	 * probe for join results. Furthermore a function named <tt>newResult</tt>
	 * can be specified that is invoked on each qualifying tuple before it is
	 * returned to the caller concerning a call to the <tt>next</tt> method. This
	 * function is a kind of factory method to model the resulting object.
	 * 
	 * <p><b>Precondition:</b> The input cursors have to be sorted and the join
	 * predicate has to be an equivalence-relation!</p>
	 * 
	 * <p>The result-tuples created by this operator are represented as an array
	 * of the input iterations' elements that are participated in this join
	 * result. If the user wants to specify a different result-type, a mapping
	 * function <tt>newResult</tt> can be specified. This function works like a
	 * kind of factory method modelling the resulting object (tuple). Further a
	 * set of comparators have to be specified, in order to compare the elements
	 * of different input iterations. Every iterator given to this constructor is
	 * wrapped to a cursor.<p>
	 *
	 * @param sortedInput0 the first sorted input iteration to be joined.
	 * @param sortedInput1 the second sorted input iteration to be joined.
	 * @param newSweepArea a parameterless function creating a new sweep-area
	 *        that is used for storing elements of the sorted input iterations.
	 * @param comparator the comparator that is used for comparing elements of
	 *        the two sorted input iterations.
	 * @param newResult a factory method (function) that takes two parameters as
	 *        argument and is invoked on each tuple where the predicate's
	 *        evaluation result is <tt>true</tt>, i.e., on each qualifying tuple
	 *        before it is returned to the caller concerning a call to the
	 *        <tt>next</tt> method.
	 * @param type the type of this join; use one of the public constants defined
	 *        in this class.
	 * @throws IllegalArgumentException if the specified type is not valid.
	 */
	public SortMergeEquivalenceJoin(Iterator sortedInput0, Iterator sortedInput1, Function newSweepArea, Comparator comparator, Function newResult, int type) throws IllegalArgumentException {
		super(sortedInput0, sortedInput1, newSweepArea, comparator, newResult);
		this.type = type;
	}

	/**
	 * Creates a new sort-merge equivalence-join operator backed on two sorted
	 * input iterations using a parameterless function to create the required 
	 * sweep-areas that are used to store the input iterations' elements and
	 * probe for join results. Uses a default
	 * {@link xxl.core.comparators.ComparableComparator comparator} for the
	 * comparison of the input cursors' elements which assumes that these
	 * elements implement the {@link java.lang.Comparable comparable} interface.
	 * Furthermore a function named <tt>newResult</tt> can be specified that is
	 * invoked on each qualifying tuple before it is returned to the caller
	 * concerning a call to* the <tt>next</tt> method. This function is a kind of
	 * factory method to model the resulting object.
	 * 
	 * <p><b>Precondition:</b> The input cursors have to be sorted and the join
	 * predicate has to be an equivalence-relation!</p>
	 * 
	 * <p>The result-tuples created by this operator are represented as an array
	 * of the input iterations' elements that are participated in this join
	 * result. If the user wants to specify a different result-type, a mapping
	 * function <tt>newResult</tt> can be specified. This function works like a
	 * kind of factory method modelling the resulting object (tuple). Further a
	 * set of comparators have to be specified, in order to compare the elements
	 * of different input iterations. Every iterator given to this constructor is
	 * wrapped to a cursor.<p>
	 *
	 * @param sortedInput0 the first sorted input iteration to be joined.
	 * @param sortedInput1 the second sorted input iteration to be joined.
	 * @param newSweepArea a parameterless function creating a new sweep-area
	 *        that is used for storing elements of the sorted input iterations.
	 * @param newResult a factory method (function) that takes two parameters as
	 *        argument and is invoked on each tuple where the predicate's
	 *        evaluation result is <tt>true</tt>, i.e., on each qualifying tuple
	 *        before it is returned to the caller concerning a call to the
	 *        <tt>next</tt> method.
	 * @param type the type of this join; use one of the public constants defined
	 *        in this class.
	 * @throws IllegalArgumentException if the specified type is not valid.
	 */
	public SortMergeEquivalenceJoin(Iterator sortedInput0, Iterator sortedInput1, Function newSweepArea, Function newResult, int type) throws IllegalArgumentException {
		super(sortedInput0, sortedInput1, newSweepArea, newResult);
		this.type = type;
	}

	/**
	 * The main method contains some examples to demonstrate the usage and the
	 * functionality of this class.
	 *
	 * @param args array of <tt>String</tt> arguments. It can be used to submit
	 *        parameters when the main method is called.
	 */
	public static void main(String[] args) {

		/*********************************************************************/
		/*                            Example 1                              */
		/*********************************************************************/
		
		java.util.LinkedList l1 = new java.util.LinkedList();
		final java.util.LinkedList l2 = new java.util.LinkedList();
		for (int i = 0; i <= 10; i++) {
			// left: odd numbers or can be divided by 4
			if (i%2 != 0 || i%4 == 0)
				l1.add(new Integer(i));
			//right: even numbers
			if (i%2 == 0)
				l2.add(new Integer(i));
		}
				
		SortMergeEquivalenceJoin join = new SortMergeEquivalenceJoin(
			l1.listIterator(),
			l2.listIterator(),
			new xxl.core.collections.sweepAreas.SortMergeEquiJoinSA(
				new xxl.core.collections.sweepAreas.ListSAImplementor(),
				0,
				2
			),
			new xxl.core.collections.sweepAreas.SortMergeEquiJoinSA(
				new xxl.core.collections.sweepAreas.ListSAImplementor(),
				1,
				2
			),
			xxl.core.comparators.ComparableComparator.DEFAULT_INSTANCE,
			Function.IDENTITY,
			OUTER_JOIN
		);

		join.open();
		
		while (join.hasNext()) {
			Object[] result = (Object[])join.next();
			System.out.println("Tuple: (" + result[0] + ", " + result[1] + ")");
		}
		
		join.close();
	}

}
