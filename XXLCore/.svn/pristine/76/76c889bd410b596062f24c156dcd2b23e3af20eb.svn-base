/* XXL: The eXtensible and fleXible Library for data processing

Copyright (C) 2000-2004 Prof. Dr. Bernhard Seeger
                        Head of the Database Research Group
                        Department of Mathematics and Computer Science
                        University of Marburg
                        Germany

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307,
USA

	http://www.xxl-library.de

bugs, requests for enhancements: request@xxl-library.de

If you want to be informed on new versions of XXL you can
subscribe to our mailing-list. Send an email to

	xxl-request@lists.uni-marburg.de

without subject and the word "subscribe" in the message body.
*/

package xxl.core.relational.cursors;

import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.Comparator;

import xxl.core.collections.bags.ArrayBag;
import xxl.core.collections.bags.Bag;
import xxl.core.cursors.AbstractCursor;
import xxl.core.cursors.MetaDataCursor;
import xxl.core.functions.Function;
import xxl.core.predicates.Equal;
import xxl.core.predicates.Predicate;
import xxl.core.relational.Tuples;
import xxl.core.relational.cursors.SortMergeJoin.PredicateBasedSA;
import xxl.core.relational.metaData.MergedResultSetMetaData;
import xxl.core.util.WrappingRuntimeException;

/**
 * This class provides the division operator of the relational algebra.
 * <br>
 * Let us consider the division of R and S with R[A1,...,Ai,B1,...,Bj]
 * and S[B1,...,Bj]. Then the result Res has schema Res[A1,...,Ai].
 * For every result Tuple res and every Tuple from s, the tuple (res,s)
 * is contained in R.
 * <br>
 * In other words, the division computes all elements of R projected to
 * the A-Attributes, that are contained in R with <b>all</b> tuples of S.
 * <br>
 * The Division is an operation that can deliver interesting information
 * from databases!
 * <p>
 * This class performs a SortMergeJoin (R natural join S). Then, it outputs
 * all elements projected to [A1,...,Ai] that occur exactly |S| times in the
 * join result.
 */
public class SortBasedDivision extends AbstractCursor implements MetaDataCursor {

	/** Internal counter saving the number of tuples of the second input. */
	protected int counter = 0;
	
	/** MetaDataCursor object of the division*/
	protected MetaDataCursor result;

	/**
	 * Constructs an instance of the SortBasedDivision operator.
	 *
	 * @param sortedDistinctCursor1 the sorted MetaDataCursor (by the all
	 *	attributes: order by A1, ..., Ai, B1, ..., Bj) containing elements
	 *	of the first input relation (no duplicates allowed).
	 * @param sortedDistinctCursor2 the sorted MetaDataCursor (by the quotient
	 *	attributes) containing elements of the second input relation (no
	 *	duplicates allowed).
	 * @param bag Bag that is used for the
	 *	sweep area of the internal {@link xxl.core.relational.cursors.SortMergeJoin} operator.
	 * @param createTuple Function that maps an Object array (column values) and a
	 *	ResultSetMetaData object to a new result Tuple. xxl.core.relational.ArrayTuple.FACTORY_METHOD
	 *	can be used.
	 */
	public SortBasedDivision (MetaDataCursor sortedDistinctCursor1, MetaDataCursor sortedDistinctCursor2, Bag bag, Function createTuple) {
		SortMergeJoin join = new SortMergeJoin(
				sortedDistinctCursor1, sortedDistinctCursor2,
				// SweepArea0 would always contain exactly one element.
				// But no solution can be generated by this SweepArea.
				// The use of an EmptyBag would be possible (without exceptions)!
				new PredicateBasedSA (new ArrayBag(1), SortMergeJoin.computeMetaDataPredicate(sortedDistinctCursor1, sortedDistinctCursor2, SortMergeJoin.NATURAL_JOIN) , 0) {
					public void reorganize(Object currentStatus, int ID) throws IllegalStateException {
						clear();
					}
				},
				new PredicateBasedSA (bag, SortMergeJoin.computeMetaDataPredicate(sortedDistinctCursor1, sortedDistinctCursor2, SortMergeJoin.NATURAL_JOIN), 1) {

					public void insert (Object o) {
						super.insert(o);
						counter++;
					}

					public void reorganize(Object currentStatus, int ID) throws IllegalStateException {
					}
				},
				new Comparator () {
					public int compare (Object o1, Object o2) {
						return 1;
					}
				},
				createTuple,
				SortMergeJoin.NATURAL_JOIN
		);
				
		MergedResultSetMetaData joinMetaData = (MergedResultSetMetaData)join.getMetaData();
		try {
			int length = ((ResultSetMetaData)sortedDistinctCursor1.getMetaData()).getColumnCount();
			int[] tmp = new int[length];
			int noOfColumns = 0;
			for (int i = 1; i <= length; i++)
				if (joinMetaData.originalMetaData(i) == 1) {
					noOfColumns++;
					tmp[i-1] = 1;
				}
				else
					tmp[i-1] = 0;
			int[] projectedColumns = new int[noOfColumns];
			for (int i = 1, j = 0; i <= length; i++)
					if (tmp[i-1] == 1)
						projectedColumns[j++] = i;
			final Comparator tupleComparator = Tuples.getTupleComparator(projectedColumns);
			this.result = new Selection(
					new Projection(join, projectedColumns, createTuple),
					new Predicate () {

						protected Object last=null;
						int noOfResults = 0;

						public boolean invoke (Object o) {
							if (last==null || tupleComparator.compare(last, o) != 0) {
								noOfResults=0;
							}
							noOfResults++;
							last = o;
							return noOfResults==counter;
						}
				 	}
			);
		}
		catch (SQLException se) {
			throw new WrappingRuntimeException(se);
		}
	}

	/**
	 * Constructs an instance of the SortBasedDivision operator.
	 * As internal Bag, Bag.FACTORY_METHOD is used.
	 *
	 * @param sortedCursor1 the sorted MetaDataCursor (by the all
	 *	attributes: order by A1, ..., Ai, B1, ..., Bj) containing elements
	 *	of the first input relation.
	 * @param sortedCursor2 the sorted MetaDataCursor (by the quotient
	 *	attributes) containing elements of the second input relation.
	 * @param createTuple Function that maps an Object array (column values) and a
	 *	ResultSetMetaData object to a new result Tuple. xxl.core.relational.ArrayTuple.FACTORY_METHOD
	 *	can be used.
	 */
	public SortBasedDivision (MetaDataCursor sortedCursor1, MetaDataCursor sortedCursor2, Function createTuple) {
		this(new SortBasedDistinct(sortedCursor1, Equal.DEFAULT_INSTANCE),
			  new SortBasedDistinct(sortedCursor2, Equal.DEFAULT_INSTANCE),
			  (Bag) Bag.FACTORY_METHOD.invoke(), createTuple
		);
	}

	/**
	 * Constructs an instance of the SortBasedDivision operator.
	 *
	 * @param sortedDistinctResultSet1 the sorted ResultSet (by the all
	 *	attributes: order by A1, ..., Ai, B1, ..., Bj) containing elements
	 *	of the first input relation (no duplicates allowed).
	 * @param sortedDistinctResultSet2 the sorted ResultSet (by the quotient
	 *	attributes) containing elements of the second input relation (no
	 *	duplicates allowed).
	 * @param bag Bag that is used for the
	 *	sweep area of the internal {@link xxl.core.relational.cursors.SortMergeJoin} operator.
	 * @param createTuple Function that maps an Object array (column values) and a
	 *	ResultSetMetaData object to a new result Tuple. xxl.core.relational.ArrayTuple.FACTORY_METHOD
	 *	can be used.
	 */
	public SortBasedDivision (ResultSet sortedDistinctResultSet1, ResultSet sortedDistinctResultSet2, Bag bag, Function createTuple) {
		this(new ResultSetMetaDataCursor(sortedDistinctResultSet1),
			 new ResultSetMetaDataCursor(sortedDistinctResultSet2),
			 bag, createTuple);
	}

	/**
	 * Constructs an instance of the SortBasedDivision operator.
	 * As internal Bag, Bag.FACTORY_METHOD is used.
	 *
	 * @param sortedResultSet1 the sorted ResultSet (by the all
	 *	attributes: order by A1, ..., Ai, B1, ..., Bj) containing elements
	 *	of the first input relation.
	 * @param sortedResultSet2 the sorted ResultSet (by the quotient
	 *	attributes) containing elements of the second input relation.
	 * @param createTuple Function that maps an Object array (column values) and a
	 *	ResultSetMetaData object to a new result Tuple. {@link xxl.core.relational.ArrayTuple#FACTORY_METHOD}
	 *	can be used.
	 */
	public SortBasedDivision (ResultSet sortedResultSet1, ResultSet sortedResultSet2, Function createTuple) {
		this(new ResultSetMetaDataCursor(sortedResultSet1),
			 new ResultSetMetaDataCursor(sortedResultSet2),
			 createTuple);
	}
	
	/**
	 * Returns <tt>true</tt> if the iteration has more elements.
	 * (In other words, returns <tt>true</tt> if <tt>next</tt> or <tt>peek</tt> would
	 * return an element rather than throwing an exception.) <br>
	 * This operation should be implemented idempotent, i.e., consequent calls to
	 * <code>hasNext()</code> do not have any effect.
	 *
	 * @return <tt>true</tt> if the cursor has more elements.
	 */
	public boolean hasNextObject() {
		return result.hasNext();
	}
	
	/**
	 * Returns the next element in the iteration.
	 * This element will be removed from the underlying collection, if
	 * <tt>next</tt> is called.
	 *
	 * @return the next element in the iteration.
	 * @throws java.util.NoSuchElementException if the iteration has no more elements.
	 */
	public Object nextObject() {
		return result.next();
	}

	/**
	 * Resets the cursor to its initial state.<br>
	 * So the caller is able to traverse the underlying collection again.
	 * The modifications, removes and updates concerning the underlying collection,
	 * are still persistent. This operation is only successful, if the
	 * underlying cursors are resetable.
	 * 
	 * @throws UnsupportedOperationException 
	 */
	public void reset () throws UnsupportedOperationException {
		super.reset();
		result.reset();
	}
	
	/** Returns true if reset is supported. This method always returns true 
	 *  because this cursor is considered as resetable. 
	 * 
	 * @return true if reset is supported */
	public boolean supportsReset() {
		return true;
	}
	
	/**Closes the cursor*/
	public void close() {
		super.close();
		result.close();
	}

	/**
	 * Returns the metadata of the division. The metadata is computed at the first call.
	 *
	 * @return ResultSetMetaData object of the division
	 */
	public Object getMetaData () {
		return result.getMetaData();
	}
}
